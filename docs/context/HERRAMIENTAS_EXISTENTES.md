# üõ†Ô∏è Herramientas Existentes - Gu√≠a de Reutilizaci√≥n

## üìã Prop√≥sito de Este Documento

Este documento es una **referencia r√°pida** de todas las herramientas y componentes ya implementados en el bot. **ANTES de crear c√≥digo nuevo, consulta aqu√≠ para reutilizar lo existente.**

---

## ‚úÖ COMPONENTES IMPLEMENTADOS Y LISTOS PARA USAR

### 1. üìä Data Sources - Sistema Completo de An√°lisis de Mercado

**Ubicaci√≥n:** `data_sources/`

#### 1.1 DataAggregator (`data_aggregator.py`)
**‚úÖ IMPLEMENTADO - USAR EN VEZ DE CREAR NUEVO**

Compila datos de m√∫ltiples fuentes en un solo lugar.

```python
from data_sources import DataAggregator

aggregator = DataAggregator(cache_db_path="data/cache.db")
data = aggregator.get_compiled_data("BTCUSDT")

# Retorna CompiledMarketData con:
print(data.coin_metrics.current_price)           # Precio actual
print(data.coin_metrics.price_change_24h)        # Cambio 24h
print(data.coin_metrics.volume_24h)              # Volumen
print(data.market_sentiment.fear_greed_index)    # Fear & Greed
print(data.global_market.btc_dominance)          # Dominancia BTC
print(data.trending_coins)                       # Coins trending
print(data.compiled_score)                       # Score agregado -1 a 1
```

**Fuentes de datos incluidas:**
- ‚úÖ CoinGecko (precios, market cap, trending)
- ‚úÖ CryptoCompare (noticias, datos sociales)
- ‚úÖ Fear & Greed Index
- ‚úÖ Global market data

---

#### 1.2 SentimentAnalyzer (`sentiment_analyzer.py`)
**‚úÖ IMPLEMENTADO - USAR PARA AN√ÅLISIS DE MERCADO**

Analiza condiciones de mercado y genera recomendaciones.

```python
from data_sources import DataAggregator, SentimentAnalyzer

aggregator = DataAggregator()
analyzer = SentimentAnalyzer(
    data_aggregator=aggregator,
    use_gpt=False  # Opcional: True si tienes OpenAI API key
)

result = analyzer.analyze_market("ETHUSDT")

# Resultado incluye:
print(result["final_recommendation"]["action"])      # BUY/SELL/HOLD
print(result["final_recommendation"]["confidence"])  # 0-100
print(result["final_recommendation"]["risk_level"])  # LOW/MEDIUM/HIGH
print(result["local_analysis"]["signals"])           # Lista de se√±ales detectadas
print(result["compiled_data"])                       # Todos los datos agregados
```

**Capacidades:**
- ‚úÖ An√°lisis de momentum de precio
- ‚úÖ Evaluaci√≥n de volumen vs market cap
- ‚úÖ Interpretaci√≥n de Fear & Greed Index
- ‚úÖ An√°lisis de mercado global
- ‚úÖ Sentiment de noticias (keyword-based)
- ‚úÖ Detecci√≥n de trending coins
- ‚úÖ GPT opcional para casos ambiguos
- ‚úÖ C√°lculo de nivel de riesgo

---

#### 1.3 CoinGeckoClient (`coingecko_client.py`)
**‚úÖ IMPLEMENTADO - API GRATUITA**

```python
from data_sources.coingecko_client import CoinGeckoClient

client = CoinGeckoClient()

# Precio simple
price = client.get_coin_price("bitcoin")

# Datos completos
data = client.get_coin_market_data("ethereum")

# Datos globales
global_data = client.get_global_market_data()

# Trending
trending = client.get_trending_coins()
```

---

#### 1.4 FearGreedClient (`fear_greed_client.py`)
**‚úÖ IMPLEMENTADO - API GRATUITA**

```python
from data_sources.fear_greed_client import FearGreedClient

client = FearGreedClient()

# √çndice actual
current = client.get_current_index()
print(current["value"])  # 0-100

# Score normalizado para trading
score = client.get_sentiment_score()  # -1 a 1

# Interpretaci√≥n
interpretation = client.interpret_index(45)
print(interpretation["classification"])  # Fear/Greed/etc
print(interpretation["action_bias"])     # bullish/bearish
```

---

#### 1.5 CacheManager (`cache_manager.py`)
**‚úÖ IMPLEMENTADO - REDUCE LLAMADAS A APIs EN ~80%**

Sistema autom√°tico de cach√© con SQLite. Ya integrado en todos los clientes, pero tambi√©n puede usarse manualmente:

```python
from data_sources.cache_manager import CacheManager

cache = CacheManager("data/cache.db")

# Guardar
cache.set("my_key", {"data": "value"}, ttl=300)

# Obtener
data = cache.get("my_key")

# Estad√≠sticas
stats = cache.get_stats()
print(f"Hit rate: {stats['hit_rate']:.1f}%")
```

---

### 2. üéØ Core Trading Components

#### 2.1 TradingEngine (`src/trading_engine.py`)
**‚úÖ IMPLEMENTADO - MOTOR PRINCIPAL DE TRADING**

Ya incluye:
- ‚úÖ Integraci√≥n con SentimentAnalyzer
- ‚úÖ An√°lisis multi-timeframe
- ‚úÖ Detecci√≥n de r√©gimen de mercado
- ‚úÖ Mean reversion y momentum strategies
- ‚úÖ Combinaci√≥n de se√±ales t√©cnicas + sentiment
- ‚úÖ Position sizing din√°mico (Kelly Criterion)
- ‚úÖ Adaptive stop-loss basado en ATR
- ‚úÖ Trailing stops
- ‚úÖ Gesti√≥n de posiciones LONG y SHORT
- ‚úÖ Reporting avanzado de performance

**No necesitas crear un nuevo trading engine, √∫salo:**

```python
from src.trading_engine import TradingEngine

engine = TradingEngine(
    config=config,
    client=binance_client,
    strategy=strategy,
    risk_manager=risk_manager,
    state_manager=state_manager,
    loggers=loggers,
    use_sentiment_analysis=True,  # ‚Üê Activa sentiment
    use_gpt=False,                # ‚Üê Opcional
)

engine.run(
    symbol="BTCUSDT",
    duration_minutes=600,
    interval_seconds=45
)
```

---

#### 2.2 Strategy (`src/strategy.py`)
**‚úÖ IMPLEMENTADO - AN√ÅLISIS T√âCNICO COMPLETO**

Incluye:
- ‚úÖ RSI, MACD, Bollinger Bands, Stochastic, ADX
- ‚úÖ Multi-timeframe analysis
- ‚úÖ Detecci√≥n de mercado lateral (ranging)
- ‚úÖ Pattern analysis
- ‚úÖ Scoring system con confianza
- ‚úÖ Umbrales configurables (modo agresivo/conservador)

```python
from src.strategy import Strategy

# Modo conservador
strategy = Strategy(
    min_volume=0,
    rsi_bounds=(35, 65),
    adx_trend_threshold=20,
    atr_volatility_ceiling=0.02,
)

# Modo agresivo
aggressive_strategy = Strategy(
    min_volume=0,
    rsi_bounds=(25, 75),
    adx_trend_threshold=12,
    atr_volatility_ceiling=0.04,
)

signal = strategy.generate_signal(df, "BTCUSDT", timeframe_summaries)
```

---

#### 2.3 RiskManager (`src/risk_manager.py`)
**‚úÖ IMPLEMENTADO - GESTI√ìN DE RIESGO AVANZADA**

Capacidades:
- ‚úÖ Position sizing b√°sico y din√°mico (Kelly)
- ‚úÖ Adaptive stop-loss basado en ATR
- ‚úÖ Trailing stops
- ‚úÖ Control de exposici√≥n m√°xima
- ‚úÖ Daily loss limits con pausa autom√°tica
- ‚úÖ Drawdown tracking con circuit breaker

```python
from src.risk_manager import RiskManager

risk_manager = RiskManager(
    max_daily_loss_pct=0.08,
    max_exposure_pct=0.5,
)

# Position sizing b√°sico
size = risk_manager.calculate_position_size(
    capital=1000,
    risk_percent=0.02,
    stop_loss_pct=0.01
)

# Position sizing din√°mico (Kelly)
size = risk_manager.calculate_dynamic_position_size(
    capital=1000,
    win_rate=0.65,
    avg_win=15,
    avg_loss=-8,
    stop_loss_pct=0.01,
    volatility=0.02
)

# Stop loss adaptativo
sl = risk_manager.calculate_adaptive_stop_loss(
    entry_price=100,
    atr=2.5,
    base_stop_pct=0.01
)
```

---

#### 2.4 MarketRegimeDetector (`src/market_regime.py`)
**‚úÖ IMPLEMENTADO - DETECTA TIPO DE MERCADO**

Detecta si el mercado est√° en:
- TRENDING_UP
- TRENDING_DOWN
- RANGING (lateral)
- VOLATILE

```python
from src.market_regime import MarketRegimeDetector

detector = MarketRegimeDetector()
regime_analysis = detector.detect_regime(df, indicators, timeframe_summaries)

print(regime_analysis.regime)           # Tipo de mercado
print(regime_analysis.confidence)       # 0-1
print(regime_analysis.recommendation)   # "momentum", "mean_reversion", "avoid"
```

---

#### 2.5 MeanReversionStrategy (`src/mean_reversion_strategy.py`)
**‚úÖ IMPLEMENTADO - ESTRATEGIA PARA MERCADOS LATERALES**

Autom√°ticamente activada por TradingEngine cuando detecta ranging market.

```python
from src.mean_reversion_strategy import MeanReversionStrategy

mr_strategy = MeanReversionStrategy(
    support_threshold=0.02,
    resistance_threshold=0.02
)

signal = mr_strategy.evaluate(symbol, current_price, indicators, patterns, timeframes)
```

---

#### 2.6 MultiTimeframeAnalyzer (`src/multi_timeframe.py`)
**‚úÖ IMPLEMENTADO - AN√ÅLISIS EN M√öLTIPLES TIMEFRAMES**

```python
from src.multi_timeframe import MultiTimeframeAnalyzer

analyzer = MultiTimeframeAnalyzer(
    client=binance_client,
    intervals=("5m", "15m", "1h"),
    candle_limit=200
)

summaries = analyzer.fetch("BTCUSDT")
for tf in summaries:
    print(f"{tf.interval}: {tf.trend_pct:+.2f}%")
```

---

### 3. üìà Indicators & Patterns

#### 3.1 Indicators (`src/indicators.py`)
**‚úÖ IMPLEMENTADO - 10+ INDICADORES T√âCNICOS**

```python
from src.indicators import calculate_indicators

indicators = calculate_indicators(df)

# Acceder a indicadores
print(indicators.rsi)
print(indicators.macd, indicators.macd_signal, indicators.macd_histogram)
print(indicators.bollinger_upper, indicators.bollinger_middle, indicators.bollinger_lower)
print(indicators.atr)
print(indicators.adx)
print(indicators.stochastic_k, indicators.stochastic_d)
```

---

#### 3.2 Patterns (`src/patterns.py`)
**‚úÖ IMPLEMENTADO - DETECCI√ìN DE PATRONES**

```python
from src.patterns import analyze_patterns

patterns = analyze_patterns(df)

print(patterns.bullish)             # Lista de patrones alcistas
print(patterns.bearish)             # Lista de patrones bajistas
print(patterns.support)             # Nivel de soporte
print(patterns.resistance)          # Nivel de resistencia
print(patterns.bullish_divergence)  # True/False
print(patterns.bearish_divergence)  # True/False
```

---

### 4. üìä Performance & Metrics

#### 4.1 PerformanceAnalyzer (`src/performance_metrics.py`)
**‚úÖ IMPLEMENTADO - M√âTRICAS COMPLETAS**

```python
from src.performance_metrics import PerformanceAnalyzer

metrics = PerformanceAnalyzer.analyze_trades(
    trades=trades_df,
    start_capital=1000,
    duration_minutes=600
)

# M√©tricas incluidas:
# - Total trades, win rate, profit factor
# - Sharpe ratio, max drawdown
# - Average win/loss, best/worst trades
# - Trades per hour, hourly/daily projections
# - Consecutive wins/losses
# - Y muchas m√°s...

PerformanceAnalyzer.print_performance_report(metrics, start_capital, end_capital)
```

---

### 5. üîß Utilities

#### 5.1 StateManager (`src/state_manager.py`)
**‚úÖ IMPLEMENTADO - PERSISTENCIA DE ESTADO**

```python
from src.state_manager import StateManager

state_manager = StateManager(
    state_file=Path("state/state.json"),
    trades_history_file=Path("state/trades.json")
)

# Guardar trade
state_manager.append_trade(trade_record)

# Cargar estado previo
state = state_manager.load()
```

---

#### 5.2 Logger System (`src/logger.py`)
**‚úÖ IMPLEMENTADO - LOGS CATEGORIZADOS**

```python
from src.logger import setup_category_loggers

loggers = setup_category_loggers(Path("logs"))

loggers["system"].info("System message")
loggers["trades"].info("Trade executed")
loggers["errors"].error("Error occurred")
loggers["api_calls"].debug("API called")
```

---

## üöÄ SCRIPTS LISTOS PARA USAR

### 1. Script de Modo Agresivo (`scripts/aggressive_trading.py`)
**‚úÖ IMPLEMENTADO**

```bash
# Ejecutar sesi√≥n agresiva de 8 horas (default)
python scripts/aggressive_trading.py --symbol ETHUSDT --duration 480

# Con GPT
python scripts/aggressive_trading.py --symbol ETHUSDT --duration 480 --use-gpt

# Cambiar intervalo
python scripts/aggressive_trading.py --symbol ETHUSDT --duration 480 --interval 30
```

---

### 2. Script Optimizado 10h (`scripts/run_optimized_10h.py`)
**‚úÖ RECI√âN IMPLEMENTADO**

**REUTILIZA:**
- DataAggregator para datos de mercado
- SentimentAnalyzer para an√°lisis
- TradingEngine para ejecutar

```bash
python scripts/run_optimized_10h.py
```

**Flujo:**
1. Analiza 8 monedas principales (BTCUSDT, ETHUSDT, etc.)
2. Usa SentimentAnalyzer para evaluar cada una
3. Calcula un "opportunity score" considerando:
   - Momentum de precio
   - Volumen/liquidez
   - Sentiment score
   - Nivel de riesgo
   - Confianza del an√°lisis
4. Selecciona la mejor moneda
5. Ajusta par√°metros seg√∫n nivel de riesgo
6. Ejecuta TradingEngine por 10 horas

---

### 3. Otros Scripts Disponibles

```bash
# Modo conservador (modo est√°ndar)
python src/main.py --symbol BTCUSDT --duration 60

# Ver resumen de performance
python scripts/ver_resumen.py

# Test de APIs
python tests/test_apis_config.py

# Test de sentiment
python tests/test_sentiment_analysis.py
```

---

## üìñ C√ìMO REUTILIZAR EN NUEVOS SCRIPTS

### Ejemplo: Script para Analizar M√∫ltiples Monedas

```python
"""Ejemplo de c√≥mo reutilizar componentes existentes."""

import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).parent.parent))

from data_sources import DataAggregator, SentimentAnalyzer

def main():
    # 1. Inicializar componentes existentes
    aggregator = DataAggregator(cache_db_path="data/cache.db")
    analyzer = SentimentAnalyzer(
        data_aggregator=aggregator,
        use_gpt=False
    )
    
    # 2. Analizar monedas
    symbols = ["BTCUSDT", "ETHUSDT", "BNBUSDT"]
    
    for symbol in symbols:
        # Usa SentimentAnalyzer (no reinventes la rueda)
        result = analyzer.analyze_market(symbol)
        
        # Accede a datos compilados
        coin = result["compiled_data"].coin_metrics
        rec = result["final_recommendation"]
        
        print(f"{symbol}:")
        print(f"  Precio: ${coin.current_price:,.2f}")
        print(f"  Acci√≥n: {rec['action']} ({rec['confidence']}%)")
        print(f"  Riesgo: {rec['risk_level']}")
        print()

if __name__ == "__main__":
    main()
```

---

### Ejemplo: Script para Backtesting (Futuro)

```python
"""Ejemplo de estructura para backtesting usando componentes existentes."""

from src.strategy import Strategy
from src.indicators import calculate_indicators
from src.patterns import analyze_patterns
import pandas as pd

def backtest_strategy(df: pd.DataFrame):
    # Reutiliza Strategy existente
    strategy = Strategy(
        min_volume=0,
        rsi_bounds=(35, 65),
        adx_trend_threshold=20,
        atr_volatility_ceiling=0.02,
    )
    
    trades = []
    
    # Simula trading sobre datos hist√≥ricos
    for i in range(100, len(df)):
        window = df.iloc[i-100:i]
        signal = strategy.generate_signal(window, "BTCUSDT")
        
        if signal:
            trades.append({
                "timestamp": df.iloc[i]["timestamp"],
                "action": signal.action,
                "price": df.iloc[i]["close"],
                "confidence": signal.confidence
            })
    
    return pd.DataFrame(trades)
```

---

## ‚ö†Ô∏è ANTES DE CREAR C√ìDIGO NUEVO

### Checklist:

- [ ] ¬øNecesito analizar datos de mercado? ‚Üí **USA DataAggregator**
- [ ] ¬øNecesito an√°lisis de sentiment? ‚Üí **USA SentimentAnalyzer**
- [ ] ¬øNecesito ejecutar trading? ‚Üí **USA TradingEngine**
- [ ] ¬øNecesito an√°lisis t√©cnico? ‚Üí **USA Strategy**
- [ ] ¬øNecesito gesti√≥n de riesgo? ‚Üí **USA RiskManager**
- [ ] ¬øNecesito indicadores? ‚Üí **USA calculate_indicators()**
- [ ] ¬øNecesito patrones? ‚Üí **USA analyze_patterns()**
- [ ] ¬øNecesito detectar tipo de mercado? ‚Üí **USA MarketRegimeDetector**
- [ ] ¬øNecesito multi-timeframe? ‚Üí **USA MultiTimeframeAnalyzer**
- [ ] ¬øNecesito m√©tricas de performance? ‚Üí **USA PerformanceAnalyzer**

---

## üìö Documentaci√≥n Adicional

- **FASE3_RESUMEN.md**: Detalles completos de integraci√≥n de datos
- **QUICK_START.md**: Inicio r√°pido en 5 minutos
- **FASE3_SETUP_GUIDE.md**: Configuraci√≥n detallada de APIs
- **INTEGRATION_COMPLETE.md**: Resumen de integraci√≥n completa
- **trading-bot-evolution.plan.md**: Plan de evoluci√≥n completo

---

## üéØ Pr√≥ximas Implementaciones Sugeridas

### Usando componentes existentes:

1. **Backtesting System**
   - Usa: Strategy, indicators, patterns
   - Nuevo: backtesting_engine.py

2. **Multi-Symbol Trading**
   - Usa: TradingEngine, SentimentAnalyzer
   - Nuevo: multi_symbol_orchestrator.py

3. **Alertas por Telegram**
   - Usa: SentimentAnalyzer para detectar oportunidades
   - Nuevo: telegram_bot.py

4. **Dashboard Web**
   - Backend: FastAPI
   - Consume: logs, state files, usa components para live data
   - Nuevo: api/ folder

5. **Machine Learning Integration**
   - Features: Usa indicators, patterns, sentiment data
   - Nuevo: ml/ folder

---

## üí° Principio Fundamental

> **"No reinventes la rueda. Reutiliza, compone, extiende."**

Todos los componentes est√°n dise√±ados para ser:
- ‚úÖ Reutilizables
- ‚úÖ Componibles
- ‚úÖ Extensibles
- ‚úÖ Testeables

**Antes de escribir c√≥digo nuevo, preg√∫ntate:**
*"¬øYa existe un componente que haga esto o parte de esto?"*

---

√öltima actualizaci√≥n: 19 de Octubre, 2025

